Convert Sorted Array to Binary Search Tree

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    TreeNode *sortedArrayToBST(vector<int> &num, int start, int end) {
        if (start > end) return NULL;
        if (start == end) 
            return new TreeNode(num[start]);
        int mid = (start + end) / 2;
        TreeNode *root = new TreeNode(num[mid]);
        if (start < mid) root->left = sortedArrayToBST(num, start, mid - 1);
        root->right = sortedArrayToBST(num, mid + 1, end);
        
        return root;
    }
    
public:
    TreeNode *sortedArrayToBST(vector<int> &num) {
        int size = num.size();
        if (size == 0) return NULL;
        
        return sortedArrayToBST(num, 0, size - 1);
    }
};

Convert Sorted List to Binary Search Tree

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedListToBST(ListNode *head) {
        if (head == NULL) return NULL;
        if (head->next == NULL) return new TreeNode(head->val);

        ListNode *ptr1 = head->next->next, *ptr2 = head;
        while (ptr1) {
            ptr1 = ptr1->next;
            if (ptr1) {
                ptr1 = ptr1->next;
                ptr2 = ptr2->next;
            }
        }
        
        ListNode *mNode = ptr2->next;
        ptr2->next = NULL;
        TreeNode *root = new TreeNode(mNode->val);
        root->left = sortedListToBST(head);
        root->right = sortedListToBST(mNode->next);
        
        return root;
    }
};

Binary Tree Zigzag Level Order Traversal

Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

return its zigzag level order traversal as:

[
  [3],
  [20,9],
  [15,7]
]

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
        vector<vector<int> > res;
        if (root == NULL) return res;
        
        stack<TreeNode *> s;
        s.push(root);
        bool leftToRight = true;
        while (!s.empty()) {
            stack<TreeNode *> s2;
            vector<int> v;
            while (!s.empty()) {
                TreeNode *n = s.top();
                s.pop();
                v.push_back(n->val);
                if (leftToRight) {
                    if (n->left) s2.push(n->left);
                    if (n->right) s2.push(n->right);
                } else {
                    if (n->right) s2.push(n->right);
                    if (n->left) s2.push(n->left);
                }
            }
            res.push_back(v);
            s = s2;
            leftToRight = !leftToRight;
        }
        
        return res;     
    }
};

Construct Binary Tree from Inorder and Postorder Traversal

Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree. 

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private TreeNode buildTree(int[] inorder, int[] postorder, int inorderStart, int inorderEnd, int postOrderStart, int postorderEnd) {
        int rootVal = postorder[postorderEnd];
        int i = inorderStart;
        while (i <= inorderEnd && inorder[i] != postorder[postorderEnd]) ++i;
        
        if (i > inorderEnd) return null;
        
        TreeNode root = new TreeNode(postorder[postorderEnd]);
        if (i > inorderStart)
            root.left = buildTree(inorder, postorder, inorderStart, i - 1, postOrderStart, postOrderStart + i - inorderStart - 1);
        if (i < inorderEnd)
            root.right = buildTree(inorder, postorder, i + 1, inorderEnd, postOrderStart + i - inorderStart, postorderEnd - 1);
            
        return root;
    }
    
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if (inorder == null || inorder.length == 0 || inorder.length != postorder.length) return null;
        return buildTree(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);
    }
}


Construct Binary Tree from Preorder and Inorder Traversal

Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree. 

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private TreeNode buildTree(int[] preorder, int[] inorder, int prerderStart, int preorderEnd, int inorderStart, int inorderEnd) {
        int rootVal = preorder[prerderStart];
        int i = inorderStart;
        while (i <= inorderEnd && inorder[i] != preorder[prerderStart]) ++i;
        
        if (i > inorderEnd) return null;
        
        TreeNode root = new TreeNode(preorder[prerderStart]);
        if (i > inorderStart)
            root.left = buildTree(preorder, inorder, prerderStart + 1, prerderStart + i - inorderStart, inorderStart, i - 1);
        if (i < inorderEnd)
            root.right = buildTree(preorder, inorder, prerderStart + i - inorderStart + 1, preorderEnd, i + 1, inorderEnd);
            
        return root;
    }
    
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0 || preorder.length != inorder.length) return null;
        return buildTree(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);
    }
}
