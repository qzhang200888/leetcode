Two sum:

public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        if (numbers == null)
            return null;
        int[] ret = new int[2];

        HashMap<String, String> map = new HashMap<String, String>();
        for (int i = 0; i < numbers.length; ++i) {
            map.put(Integer.toString(target - numbers[i]), Integer.toString(i));
        }

        for (int i = 0; i < numbers.length; ++i) {
            if (map.containsKey(Integer.toString(numbers[i]))) {
                int val1 = Integer.parseInt(map.get(Integer.toString(numbers[i])));
                int val2 = i;
                if (val1 < val2) {
                    ret[0] = val1 + 1;
                    ret[1] = val2 + 1;
                    return ret;
                } else if (val1 > val2) {
                    ret[0] = val2 + 1;
                    ret[1] = val1 + 1;
                    return ret;
                }
            }
        }

        return null;
    }
}

Binary Tree Postorder Traversal

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ArrayList<Integer> postorderTraversal(TreeNode root) {
        if (root == null) {
            return new ArrayList<Integer>();
        }
        ArrayList<Integer> left = postorderTraversal(root.left);
        ArrayList<Integer> right = postorderTraversal(root.right);
        
        if (left != null && right != null) {
            left.addAll(right);
        } else if (right != null) {
            left = right;
        }
        
        if (left != null) {
            left.add(new Integer(root.val));
        }
        
        return left;
    }
}

Binary Tree Preorder Traversal

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
         if (root == null) {
            return new ArrayList<Integer>();
        }
        ArrayList<Integer> left = preorderTraversal(root.left);
        ArrayList<Integer> right = preorderTraversal(root.right);
        
        ArrayList<Integer> rootNode = new ArrayList<Integer>();
        rootNode.add(root.val);
        
        if (left != null) {
            rootNode.addAll(left);
        }
        
        if (right != null) {
            rootNode.addAll(right);
        }
        
        return rootNode;       
    }
}

Linked List Cycle

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null)
            return false;
            
        ListNode first = head, second = head.next;
        while (first != null && second != null) {
            first = first.next;
            second = second.next;
            if (second == null) {
                return false;
            }
            
            second = second.next;
            
            if (first == second) {
                return true;
            }
        }
        
        return false;
    }
}

Same Tree

Given two binary trees, write a function to check if they are equal or not. 

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;
        if ((p == null && q != null) || (p != null && q == null) )
            return false;
        if (p.val != q.val)
            return false;
        if (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))
            return true;
        return false;
    }
}

Gas Station
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

public class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int i = 0;
        while (i < gas.length) {
            if (gas[i] < cost[i]) {
                ++i;
                continue;
            }
            int gasAmount = gas[i] - cost[i];
            int j = (i + 1) % gas.length;
            while (j != i) {
               gasAmount += gas[j] - cost[j];
               if (gasAmount < 0) {
                   break;
               }
               j = (j + 1) % gas.length;
            }
            
            if (j == i) {
                return j;
            } else if (j > i) {
                i = j + 1;
            } else {
                break;
            }
        }

        return -1;
    }
}

Add Two Numbers

You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    private ListNode add(int num, ListNode l) {
        if (num == 0)
            return l;
            
        ListNode newList;
        if (l != null) {
            newList = new ListNode((l.val + num) % 10);
            num = (l.val + num) / 10;
            l = l.next;
        } else {
            newList = new ListNode(num % 10);
            num = num / 10;           
        }
        
        ListNode cur = newList;
        while (num != 0 && l != null) {
            cur.next = new ListNode((l.val + num) % 10);
            num = (l.val + num) / 10;
            cur = cur.next;
            l = l.next;
        }
        if (num == 0)
            cur.next = l;
        else cur.next = new ListNode(num);
            
        return newList;
    }
    
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null)
            return l2;
        
        if (l2 == null)
            return l1;
            
        int num = (l1.val + l2.val) / 10;
        ListNode head = new ListNode((l1.val + l2.val) % 10);
        ListNode cur = head;
        l1 = l1.next;
        l2 = l2.next;
        
        while (l1 != null && l2 != null) {
           cur.next = new ListNode((l1.val + l2.val + num) % 10);
           num = (l1.val + l2.val + num) / 10;
           cur = cur.next;
           l1 = l1.next;
           l2 = l2.next;
        }
        
        if (l1 != null) {
            cur.next = add(num, l1);
        } else if (l2 != null) {
            cur.next = add(num, l2);
        } else if (num != 0) {
            cur.next = new ListNode(num);
        }
        
        return head;
    }
}

String to Integer (atoi)

public class Solution {
    public int atoi(String str) {
        if (str == null || str.length() == 0)
            return 0;
        
        int length = str.length();
        
        int i = 0;
        while (i < length && str.charAt(i) == ' ')
            ++i;
            
        int sign = 1;
        if (i < length && str.charAt(i) == '-') {
            sign = -1;
            ++i;
        } else if (i < length && str.charAt(i) == '+')
            ++i;
            
        long ret = 0;
        while (i < length) {
            char c = str.charAt(i);
            if (c < '0' || c > '9')
                break;
                
            ret *= 10;
            ret += sign * (c - '0');
            if (sign == 1 && ret >= Integer.MAX_VALUE) {
                ret = Integer.MAX_VALUE;
                break;
            } else if (sign == -1 && ret <= Integer.MIN_VALUE) {
                ret = Integer.MIN_VALUE;
                break;
            }
            ++i;
        }
        
        return (int)ret;
    }
}

Valid Palindrome

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

public class Solution {
    public boolean isPalindrome(String s) {
        if (s == null)
            return true;
        if (s.length() < 2)
            return true;
            
        int i = 0, j = s.length() - 1;
        while (i < j) {
            if (!Character.isLetter(s.charAt(i)) && !Character.isDigit(s.charAt(i))) {
                ++i;
                continue;
            }
            if (!Character.isLetter(s.charAt(j)) && !Character.isDigit(s.charAt(j))) {
                --j;
                continue;
            }
            
            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))
                return false;
            ++i;
            --j;
        }
        
        return true;
    }
}

Binary Tree Maximum Path Sum

Given a binary tree, find the maximum path sum.
The path may start and end at any node in the tree.
For example:
Given the below binary tree,
      1
      / \
     2   3

Return 6.


/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int[] maxPathSumPair(TreeNode root) {
        int[] ret = new int[2];
        ret[0] = 0;
        ret[1] = 0;
        
        if (root == null)
            return ret;
            
        int[] leftRet = maxPathSumPair(root.left);
        int[] rightRet = maxPathSumPair(root.right);
        
        if (leftRet[1] > rightRet[1])
            ret[1] = leftRet[1] + root.val;
        else ret[1] = rightRet[1] + root.val;
        ret[1] = ret[1] > root.val ? ret[1] : root.val;
        
        int sum = ret[1];
        if (root.left != null)
            sum = sum > leftRet[0] ? sum : leftRet[0];
        if (root.right != null)
            sum = sum > rightRet[0] ? sum : rightRet[0];
        
        int tempSum = leftRet[1] + root.val + rightRet[1];
        sum = sum > tempSum ? sum : tempSum;
        sum = sum > root.val ? sum : root.val;
        
        ret[0] = sum;
        
        return ret;
    }
    
    public int maxPathSum(TreeNode root) {
        int[] sumPair = maxPathSumPair(root);
        return sumPair[0];
    }
}

Longest Substring Without Repeating Characters

Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.

public class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null)
            return 0;
            
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        int length = s.length();
        int start = 0, end = 0, curStart = 0;
        
        for (int i = 0; i < length; ++i) {
            Character c = new Character(s.charAt(i));
            if (map.containsKey(c)) {
                if ((i - curStart) > (end - start)) {
                    start = curStart;
                    end = i;
                }
                
                int newPos = map.get(c).intValue();
                for (int j = curStart; j <= newPos; ++j)
                    map.remove(new Character(s.charAt(j)));
                curStart = newPos + 1;
            }
            
            map.put(c, new Integer(i));
        }
        
        if ((length - curStart) > (end - start)) {
            start = curStart;
            end = length;
        }
        
        if (end != 0)
            return end - start;
        return length;
    }
}


Regular Expression Matching ?

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true


Candy
There are N children standing in a line. Each child is assigned a rating value.
You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?

public class Solution {
    public int candy(int[] ratings) {
        if (ratings == null || ratings.length == 0)
            return 0;
            
        int[] candies = new int[ratings.length];
        candies[0] = 1;
        
        for (int i = 1; i < ratings.length; ++i) {
            if (ratings[i] > ratings[i-1])
                candies[i] = candies[i-1] + 1;
            else candies[i] = 1;
        }
        
        for (int i = ratings.length - 2; i >= 0; --i) {
            if (ratings[i] > ratings[i+1] && candies[i] <= candies[i+1])
                candies[i] = candies[i+1] + 1;
        }
        
        int total = 0;
        for (int i = 0; i < ratings.length; ++i)
            total += candies[i];
        
        return total;
    }
}

Longest Palindromic Substring
Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

public class Solution {
    public String longestPalindrome(String s) {
        if (s == null)
           return null;
           
        int start = 0, end = 0;
        int length = s.length();
        for (int i = 0; i < length; ++i) {
            int j = 1;
            while (i - j >= 0 && i + j < length) {
                if (s.charAt(i-j) != s.charAt(i+j))
                    break;
                ++j;
            }
            
            if (end - start < 2 * j - 1) {
                start = i - j + 1;
                end = i + j;
            }
            
            j = i + 1;
            int k = i;
            while (k >= 0 && j < length) {
                if (s.charAt(k) != s.charAt(j))
                    break;
                ++j;
                --k;
            }
            
            if (end - start < j - k - 1) {
                start = k + 1;
                end = j;
            }
        }
        
        return s.substring(start, end);
    }
}

Remove Duplicates from Sorted Array
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this in place with constant memory.
For example,
Given input array A = [1,1,2],
Your function should return length = 2, and A is now [1,2].

public class Solution {
    public int removeDuplicates(int[] A) {
        if (A == null)
            return 0;
            
        HashSet set = new HashSet();
        
        int count = 0, pos = 0;
        for (int i = 0; i < A.length; ++i) {
            if (set.contains(new Integer(A[i])))
                continue;
            else {
                set.add(new Integer(A[i]));
                A[pos++] = A[i];
                ++count;
            }
        }
        
        return count;
    }
}

Symmetric Tree
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree is symmetric:
   1
   / \
  2   2
 / \ / \
3  4 4  3

But the following is not:
   1
   / \
  2   2
   \   \
   3    3


/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private boolean isSymmetricTree(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;
        if ((p == null && q != null) || (p != null && q == null) )
            return false;
        if (p.val != q.val)
            return false;
        if (isSymmetricTree(p.left, q.right) && isSymmetricTree(p.right, q.left))
            return true;
        return false;
    }
    
    public boolean isSymmetric(TreeNode root) {
        if (root == null)
            return true;
        return isSymmetricTree(root.left, root.right);
    }
}

Maximum Depth of Binary Tree
Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        if (leftDepth > rightDepth)
            return leftDepth + 1;
        return rightDepth + 1;
    }
}

Merge Sorted Array
Given two sorted integer arrays A and B, merge B into A as one sorted array.

public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int i = 0, j = 0, p = 0;
        int[] C = new int[m+n];
        while (i < m && j < n) {
            if (A[i] > B[j])
                C[p++] = B[j++];
            else C[p++] = A[i++];
        }
        
        while (i < m)
            C[p++] = A[i++];
        while (j < n)
            C[p++] = B[j++];
            
        for (i = 0; i < m+n; ++i)
            A[i] = C[i];
    }
}

Evaluate Reverse Polish Notation
Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.
Some examples:
 ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

C++:

class Solution {
public:
    int evalRPN(vector<string> &tokens) {
        if (tokens.empty())
            return 0;
 
        string str = tokens.back();
        tokens.pop_back();
        if (str != "+" && str != "-" && str != "*" && str != "/") {
            return atoi(str.c_str());
        }

        int num2;
        string str2 = tokens.back();
        if (str2 != "+" && str2 != "-" && str2 != "*" && str2 != "/") {
            num2 = atoi(str2.c_str());
            tokens.pop_back();
        } else {
            num2 = evalRPN(tokens);
        }
          
        int num1;
        string str1 = tokens.back();
        if (str1 != "+" && str1 != "-" && str1 != "*" && str1 != "/") {
            num1 = atoi(str1.c_str());
            tokens.pop_back();
        } else {
            num1 = evalRPN(tokens);
        }
        
        int ret;
        
        if (str == "+")
            ret = num1 + num2;
        else if (str == "-")
            ret = num1 - num2;
        else if (str == "*")
            ret = num1 * num2;
        else if (str == "/")
            ret = num1 / num2;
                
        return ret;
    }
};

Sort List
Sort a linked list in O(n log n) time using constant space complexity.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        if (head == NULL)
            return NULL;
            
        ListNode *left = NULL, *right = NULL;
        ListNode *cur = head->next, *leftPtr = NULL, *rightPtr = NULL, *headPtr = head;
        while (cur != NULL) {
            ListNode *tmp = cur;
            cur = cur->next;
            if (tmp->val < head->val) {
                if (leftPtr == NULL) {
                    left = tmp;
                    leftPtr = left;
                } else {
                    leftPtr->next = tmp;
                    leftPtr = leftPtr->next;
                }
            } else if (tmp->val > head->val) {
                if (rightPtr == NULL) {
                    right = tmp;
                    rightPtr = right;
                } else {
                    rightPtr->next = tmp;
                    rightPtr = rightPtr->next;
                }
            } else {
                headPtr->next = tmp;
                headPtr = headPtr->next;              
            }
        }
        
        if (leftPtr) {
            leftPtr->next = NULL;
            left = sortList(left);
            leftPtr = left;
            while (leftPtr->next)
                leftPtr = leftPtr->next;
        }
        
        if (rightPtr) {
            rightPtr->next = NULL;
            right = sortList(right);
        }
            
        headPtr->next = right;
        if (leftPtr) {
            leftPtr->next = head;
            return left;
        }
        
        return head;
    }
};

Insertion Sort List
Sort a linked list using insertion sort.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        ListNode *sortedList = NULL;
        while (head != NULL) {
            if (sortedList == NULL) {
                sortedList = head;
                head = head->next;
                sortedList->next = NULL;
                continue;
            }
            
            ListNode *ptr = sortedList, *prevPtr = NULL;
            while (ptr->next != NULL && ptr->val <= head->val) {
                prevPtr = ptr;
                ptr = ptr->next;
            }
            
            if (prevPtr == NULL) {
                if (ptr->val < head->val) {
                    ListNode *tmp = ptr->next;
                    ptr->next = head;
                    head = head->next;
                    ptr->next->next = tmp;
                } else {
                    sortedList = head;
                    head = head->next;
                    sortedList->next = ptr;
                }
            } else if (ptr->val > head->val) {
                prevPtr->next = head;
                head = head->next;
                prevPtr->next->next = ptr;
            } else {
                ptr->next = head;
                head = head->next;
                ptr->next->next = NULL;              
            }
        }
        
        return sortedList;
    }
};

Reorder List

Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}. 


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode *head) {
        if (head == NULL || head->next == NULL)
            return;
            
        vector<ListNode *> v;
        ListNode *ptr = head;
        while (ptr) {
            v.push_back(ptr);
            ptr = ptr->next;
        }
        
        int i = 0, j = v.size() - 1;
        ListNode *lastPtr = NULL;
        while (i < j) {
           ListNode *front = v.at(i);
           ListNode *back = v.at(j);
           
           if (lastPtr != NULL) {
               lastPtr->next = front;
           }
           
           front->next = back;
           lastPtr = back;
               
           ++i;
           --j;
        }
        
        if (i == j) {
            lastPtr->next = v.at(i);
            lastPtr->next->next = NULL;
        } else lastPtr->next = NULL;
    }
};


Sum Root to Leaf Numbers

Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

For example,

    1
   / \
  2   3

The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.

Return the sum = 12 + 13 = 25. 

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int sumNumbers(TreeNode *node, int topNum) {
        if (node == NULL) {
            return 0;
        }
        
        int newTopNum = topNum * 10 + node->val;
        if (node->left == NULL && node->right == NULL) {
            return newTopNum;
        }
        
        int leftSum = 0, rightSum = 0;
        if (node->left)
            leftSum = sumNumbers(node->left, newTopNum);
        if (node->right)
            rightSum = sumNumbers(node->right, newTopNum);
        
        return leftSum + rightSum;
    }
    
public:
    int sumNumbers(TreeNode *root) {
        return sumNumbers(root, 0);
    }
};

Single Number

Given an array of integers, every element appears twice except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 

public class Solution {
    public int singleNumber(int[] A) {
        if (A == null)
            return 0;
            
        HashSet set = new HashSet();
        for (int i = 0; i < A.length; ++i) {
            Integer num = new Integer(A[i]);
            if (set.contains(num)) {
                set.remove(num);
            } else {
                set.add(num);
            }
        }
        
        if (set.size() != 1)
            return 0;
        
        Iterator iterator = set.iterator();
        
        return ((Integer)iterator.next()).intValue();
    }
}

without using extra memory:

class Solution {
public:
    int singleNumber(int A[], int n) {
        int ret = 0;
        for (int i = 0; i < n; ++i)
            ret ^= A[i];
        return ret;
    }
};

Single Number II

Given an array of integers, every element appears three times except for one. Find that single one. 

public class Solution {
    public int singleNumber(int[] A) {
        if (A == null)
            return 0;
            
        HashSet set1 = new HashSet(), set2 = new HashSet();
        for (int i = 0; i < A.length; ++i) {
            Integer num = new Integer(A[i]);
            if (!set1.contains(num)) {
                set1.add(num);
            } else if (!set2.contains(num)) {
                set2.add(num);
            } else {
                set1.remove(num);
                set2.remove(num);
            }
        }
        
        if (set1.size() != 1)
            return 0;
        
        Iterator iterator = set1.iterator();
        
        return ((Integer)iterator.next()).intValue();        
    }
}

Word Break

Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code". 

class Solution {
    bool wordBreak(string s, unordered_set<string> &dict, unordered_set<string> &nonWords) {
        for (int i = 1; i <= s.length(); ++i) {
            unordered_set<string>::const_iterator it = dict.find (s.substr(0, i));
            if (it == dict.end())
                continue;
                
            if (i == s.length())
                return true;
                
            it = nonWords.find (s.substr(i));
            if (it != nonWords.end())
                continue;
                
            if (wordBreak(s.substr(i), dict, nonWords)) {
                return true;
            } else {
                nonWords.insert(s.substr(i));
            }
        }
        
        return false;     
    }
    
public:
    bool wordBreak(string s, unordered_set<string> &dict) {
        unordered_set<string> nonWords;
        return wordBreak(s, dict, nonWords);
    }
};


Word Break II

 Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"]. 

class Solution {
    vector<string> wordBreak(string s, unordered_set<string> &dict, unordered_set<string> &nonWords) {
        vector<string> ret;
        for (int i = 1; i <= s.length(); ++i) {
            unordered_set<string>::const_iterator it = dict.find (s.substr(0, i));
            if (it == dict.end())
                continue;
                
            if (i == s.length()) {
                ret.push_back(s);
                break;
            }
                
            it = nonWords.find (s.substr(i));
            if (it != nonWords.end())
                continue;
                
            vector<string> v = wordBreak(s.substr(i), dict, nonWords);
            if (!v.empty()) {
                  for (vector<string>::iterator it = v.begin(); it != v.end(); ++it) {
                      string newStr = s.substr(0, i).append(" ");
                      newStr = newStr.append(*it);
                      ret.push_back(newStr);
                  }
            } else {
                nonWords.insert(s.substr(i));
            }
        }
    
        return ret;
    }
    
public:
    vector<string> wordBreak(string s, unordered_set<string> &dict) {
        unordered_set<string> nonWords;
        return wordBreak(s, dict, nonWords);        
    }
};


Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0)
            return 0;
            
        int profit = 0, buyIndex = 0, sellIndex = 0;
        for (int i = 1; i < prices.length; ++i) {
            if (prices[buyIndex] > prices[i]) {
                buyIndex = i;
            } else if (prices[sellIndex] < prices[i] || sellIndex < buyIndex) {
                sellIndex = i;
            }
            
            if (prices[sellIndex] - prices[buyIndex] > profit && sellIndex >= buyIndex) {
                profit = prices[sellIndex] - prices[buyIndex];
            }
        }
        
        return profit;
    }
}


Best Time to Buy and Sell Stock II

Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2)
            return 0;
            
        int profit = 0, buyIndex = 0, sellIndex = 0;
        for (int i = 1; i < prices.length - 1; ++i) {
            if (prices[i] <= prices[i-1] && prices[i] <= prices[i+1] && i > sellIndex) {
                buyIndex = i;
            } else if (prices[i] >= prices[i-1] && prices[i] >= prices[i+1] && buyIndex >= sellIndex) {
                profit += prices[i] - prices[buyIndex];
                sellIndex = i;
            }
        }
      
        if (prices[prices.length - 2] < prices[prices.length - 1] && buyIndex >= sellIndex) {
                profit += prices[prices.length - 1] - prices[buyIndex];
        }
        
        return profit;
    }
}


Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    bool isBalanced(TreeNode *root, int &depth) {
        if (root == NULL) {
            depth = 0;
            return true;
        }
        
        int ret = true;
        
        int leftDepth, rightDepth;
        if (!isBalanced(root->left, leftDepth))
            ret = false;
        if (!isBalanced(root->right, rightDepth))
            ret = false;
        if (ret && (leftDepth - rightDepth > 1 || leftDepth - rightDepth < -1))
            ret = false;
            
        if (leftDepth > rightDepth)
            depth = leftDepth + 1;
        else depth = rightDepth + 1;
        
        return ret;
    }
    
public:
    bool isBalanced(TreeNode *root) {
        int depth;
        return isBalanced(root, depth);
    }
};


Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == NULL) {
            return 0;
        }
        
        int leftMinDepth = minDepth(root->left);
        int rightMinDepth = minDepth(root->right);
        
        if (root->left == NULL)
            return rightMinDepth + 1;
            
        if (root->right == NULL)
            return leftMinDepth + 1;
            
        if (leftMinDepth > rightMinDepth)
            return rightMinDepth + 1;
        
        return leftMinDepth + 1;
    }
};

Path Sum

 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == NULL) {
            return false;
        }
        
        if (root->left == NULL && root->right == NULL) {
            return root->val == sum;
        }
        
        if (root->left != NULL) {
            if (hasPathSum(root->left, sum - root->val))
                return true;
        }
        
        if (root->right != NULL) {
            if (hasPathSum(root->right, sum - root->val))
                return true;
        }
        
        return false;
    }
};


Path Sum II

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

return

[
   [5,4,11,2],
   [5,8,4,5]
]

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > pathSum(TreeNode *root, int sum) {
        vector<vector<int> > ret;
        if (root == NULL) {
            return ret;
        }
        
        if (root->left == NULL && root->right == NULL) {
            if (root->val == sum) {
                vector<int> v;
                v.push_back(root->val);
                ret.push_back(v);
            }
            return ret;
        }
        
        if (root->left != NULL) {
            vector<vector<int> > leftV = pathSum(root->left, sum - root->val);
            for (vector<vector<int> >::iterator it = leftV.begin(); it != leftV.end(); ++it) {
                (*it).insert((*it).begin(), root->val);
                ret.push_back(*it);
            }
        }
        
        if (root->right != NULL) {
            vector<vector<int> > rightV = pathSum(root->right, sum - root->val);
            for (vector<vector<int> >::iterator it = rightV.begin(); it != rightV.end(); ++it) {
                (*it).insert((*it).begin(), root->val);
                ret.push_back(*it);
            }
        }
        
        return ret;       
    }
};


Word Ladder

 Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:

    Only one letter can be changed at a time
    Each intermediate word must exist in the dictionary

For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]

As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.

Note:

    Return 0 if there is no such transformation sequence.
    All words have the same length.
    All words contain only lowercase alphabetic characters.

class Solution {
public:
    int ladderLength(string start, string end, unordered_set<string> &dict) {
        if (start == end)
            return 1;
            
        unordered_set<string> checked;
        queue<string> queue, tmpQueue;
        queue.push(start);
        checked.insert(start);
        int level = 1;
        while(!queue.empty()) {
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                string s = queue.front();
                queue.pop();
                 
                for (int j = 0; j < s.size(); ++j) {
                    char cc = s[j];
                    for (char c = 'a'; c <= 'z'; ++c) {
                        if (s[j] != c) {
                            s[j] = c;
                            if (dict.find(s) != dict.end() && checked.count(s) == 0) {
                                if (s == end)
                                    return level + 1;
                                tmpQueue.push(s);
                                checked.insert(s);
                            }
                        }
                    }
                    s[j] = cc;
                }
            }
            
            swap(queue, tmpQueue);
            ++level;
        }
        
        return 0;
    }
};


Binary Tree Inorder Traversal

Given a binary tree, return the inorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3

return [1,3,2].

Note: Recursive solution is trivial, could you do it iteratively?

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> v;
        if (root == NULL)
            return v;
        vector<int> left = inorderTraversal(root->left);
        vector<int> right = inorderTraversal(root->right);
        
        left.push_back(root->val);
        left.insert(left.end(), right.begin(), right.end());
        
        return left;
    }
};

Remove Nth Node From End of List

Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

   After removing the second node from the end, the linked list becomes 1->2->3->5.

Note:
Given n will always be valid.
Try to do this in one pass. 

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        ListNode *first = head, *second = NULL;
        for (int i = 0; i < n; ++i)
            first = first->next;
            
        if (first) {
            first = first->next;
            second = head;
        }
        
        while (first) {
            first = first->next;
            second = second->next;
        }
        
        if (second == NULL) {
            second = head;
            head = head->next;
            delete second;
            return head;
        }
        
        ListNode *tmp = second->next;
        second->next = second->next->next;
        delete tmp;
        
        return head;
    }
};

Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings. 

public class Solution {
    public String longestCommonPrefix(String[] strs) {
        String ret = "";
        if (strs == null || strs.length == 0)
            return ret;
            
        int i = 0;
        while (true) {
            if (i >= strs[0].length()) return ret;
            
            char c = strs[0].charAt(i);
            for (int j = 1; j < strs.length; ++j) {
                if (i >= strs[j].length()) return ret;
                if (c != strs[j].charAt(i)) return ret;
            }
            
            ret += c;
            ++i;
        }
    }
}


Valid Parentheses

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

public class Solution {
    public boolean isValid(String s) {
        Stack stack = new Stack();
        int length = s.length();
        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);
            if (c == '(' || c == '{' || c == '[') {
                stack.push(new Character(c));
            }
            if (c == ')' || c == '}' || c == ']') {
                if (stack.empty()) return false;
                char c1 = ((Character)stack.pop()).charValue();
                if (c == ')' && c1 != '(') return false;
                if (c == '}' && c1 != '{') return false;
                if (c == ']' && c1 != '[') return false;
            }            
        }
        return stack.empty();
    }
}

Swap Nodes in Pairs

 Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode third = head.next.next;
        head.next.next = head;
        head = head.next;
        head.next.next = swapPairs(third);
        
        return head;
    }
}

Generate Parentheses

 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

"((()))", "(()())", "(())()", "()(())", "()()()" 

public class Solution {
    public ArrayList<String> generateParenthesis(int n) {
        ArrayList<String> list = new ArrayList<String>();
        if (n == 0)
            return list;
        if (n == 1) {
            list.add("()");
            return list;
        }
        
        for (int i = 1; i <= n / 2; ++i) {
            if (i == 1) {
                ArrayList<String> tmpList = generateParenthesis(n-1);
                for (String s : tmpList) {
                    list.add("(" + s + ")");
                    list.add(s + "()");
                    list.add("()" + s); 
                }
            } else {
                ArrayList<String> tmpList1 = generateParenthesis(i);
                ArrayList<String> tmpList2 = generateParenthesis(n-i);
                for (String s1 : tmpList1)
                    for (String s2 : tmpList2) {
                        list.add(s1 + s2);
                        list.add(s2 + s1);
                    }
            }
        }
        
        HashSet set = new HashSet();
        int size = list.size();
        for (int i = size - 1; i >= 0; --i) {
            if (set.contains(list.get(i))) {
                list.remove(i);
            } else {
                set.add(list.get(i));
            }
        }
        return list;
    }
}

Remove Element

Given an array and a value, remove all instances of that value in place and return the new length.

The order of elements can be changed. It doesn't matter what you leave beyond the new length. 

public class Solution {
    public int removeElement(int[] A, int elem) {
        if (A == null || A.length == 0) return 0;
        
        int j = A.length;
        while (j > 0 && A[j-1] == elem)
            --j;
            
        for (int i = 0; i < A.length && i < j; ++i) {
            if (A[i] == elem) {
                A[i] = A[j-1];
                A[j-1] = elem;
                while (A[j-1] == elem)
                    --j;
            }
        }
        return j;
    }
}

Container With Most Water

Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container. 

class Solution {
public:
    int maxArea(vector<int> &height) {
        if (height.size() < 1)
            return 0;
            
        int i = 0, j = height.size() -1;
        int amount = 0;
        while (i < j) {
            int minHeight = height[j] < height[i] ? height[j] : height[i];
            int newAmount = (j - i) * minHeight;
            if (newAmount > amount)
                amount = newAmount;
            if (height[j] > height[i]) {
                int leftHeight = height[i];
                do {
                    ++i;
                } while (i < j && height[i] <= leftHeight);
            } else {
                int rightHeight = height[j];
                do {
                    --j;
                } while (i < j && height[j] <= rightHeight);               
            }
        }
        
        return amount;
    }
};

Next Permutation

Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

public class Solution {
    public void nextPermutation(int[] num) {
        if (num == null) return;
        int i = -1;
        for (i = num.length - 1; i > 0; --i) {
            if (num[i] > num[i-1]) {
                int j = num.length - 1;
                while (num[j] <= num[i-1])
                    --j;
                    
                int tmp = num[j];
                num[j] = num[i-1];
                num[i-1] = tmp;
                
                int k = num.length - 1;
                j = i;
                while(j < k) {
                    tmp = num[j];
                    num[j] = num[k];
                    num[k] = tmp;
                    ++j;
                    --k;
                }
                break;
            }
        }
        
        if (i == 0) {
            for (int j = 0; j < num.length / 2; ++j) {
                 int tmp = num[j];
                 num[j] = num[num.length - 1 - j];
                 num[num.length - 1 - j] = tmp;               
            }
        }
    }
}

Search for a Range

Given a sorted array of integers, find the starting and ending position of a given target value.
Your algorithm's runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].

For example,
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4]. 

public class Solution {
    public int[] searchRange(int[] A, int target) {
        int[] ret = new int[2];
        ret[0] = ret[1] = -1;
        if (A == null || A.length == 0) {
            return ret;
        }
        
        int i = 0, j = A.length - 1;
        while (i < j & i + 1 < j) {
            int m = (i+j) / 2;
            if (A[m] >= target)
                j = m;
            else i = m;
        }
     
        if (A[i] == target) {
            ret[0] = i;
        } else if (A[j] == target) {
            ret[0] = j;
        } else {
            return ret;
        }
        
        i = 0; j = A.length - 1;
        while (i < j & i + 1 < j) {
            int m = (i+j) / 2;
            if (A[m] > target)
                j = m;
            else i = m;
        }
        
        if (A[j] == target) {
            ret[1] = j;
        } else if (A[i] == target) {
            ret[1] = i;
        }
        
        return ret;
    }
}

Search Insert Position

Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You may assume no duplicates in the array.

Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0 

public class Solution {
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) return 0;
        
        int i = 0, j = A.length - 1;
        if (A[j] < target) return A.length;
        else if (A[i] > target) return 0;
        
        while (i + 1 < j) {
            int m = (i+j)/2;
            if (A[m] == target)
                return m;
            else if (A[m] < target)
                i = m;
            else j = m;
        }
        
        if (A[i] == target) return i;
        else return j;
    }
}

Remove Duplicates from Sorted List

Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3. 

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if (head == NULL || head->next == NULL) return head;
        ListNode *ptr = head;
        while (ptr->next != NULL) {
            if (ptr->val != ptr->next->val)
                ptr = ptr->next;
            else {
                ListNode *tmp = ptr->next;
                ptr->next = ptr->next->next;
                delete tmp;
            }
        }
        return head;
    }
};

Plus One

Given a non-negative number represented as an array of digits, plus one to the number.
The digits are stored such that the most significant digit is at the head of the list.

class Solution {
public:
    vector<int> plusOne(vector<int> &digits) {
        int c = 1;
        for (int i = digits.size() - 1; i >= 0; --i) {
            int d = digits.at(i);
            digits[i] = (d + c) % 10;
            c = (d + c) / 10;
            if (c == 0) break;
        }
        
        if (c > 0) digits.insert(digits.begin(), c);
        
        return digits;
    }
};

Unique Paths

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
How many possible unique paths are there?

class Solution {
public:
    int uniquePaths(int m, int n) {
        int **M = new int*[m];
        for (int i = 0; i < m; ++i)
            M[i] = new int[n];
            
        for (int i = 0; i < m; ++i)
            M[i][0] = 1;
        for (int i = 0; i < n; ++i)
            M[0][i] = 1;
            
        for (int i = 1; i < m; ++i)
            for (int j = 1; j < n; ++j)
                M[i][j] = M[i-1][j] + M[i][j-1];
            
        int ret = M[m-1][n-1];
        
        for (int i = 0; i < m; ++i)
            delete[] M[i];
        delete[] M;
        
        return ret;
    }
};

Decode Ways

A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26

Given an encoded message containing digits, determine the total number of ways to decode it.

For example,
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2. 

class Solution {
public:
    int numDecodings(string s) {
        if (s.empty()) return 0;
        
        int size = s.size();
        int *nums = new int[size];
        for (int i = 0; i < size; ++i)
            nums[i] = 0;
            
        if (s[size-1] >= '1' && s[size-1] <= '9') {
            nums[size-1] = 1;
        
        for (int i = size - 2; i >= 0; --i)
            if (s[i] > '0' && s[i] <= '9') {
                nums[i] += nums[i+1];
                if (s[i+1] >= '0' && ((s[i] == '1' && s[i+1] <= '9') || (s[i] == '2' && s[i+1] <= '6'))) {
                    if (i < size - 2)
                        nums[i] += nums[i+2];
                    else nums[i] += 1;
                }
            }
        
        int ret = nums[0];
        delete[] nums;
        return ret;
    }
};

Unique Binary Search Trees

Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

For example,
Given n = 3, there are a total of 5 unique BST's.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

class Solution {
public:
    int numTrees(int n) {
        int *values = new int[n];
        values[0] = 1;
        
        for (int i = 1; i < n; ++i) {
            values[i] = values[i-1] * 2;
            for (int j = 1; j < i; ++j) {
                values[i] += values[j-1] * values[i-j-1];
            }
        }
        
        int res = values[n-1];
        delete[] values;
        return res;
    }
};

Validate Binary Search Tree

 Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

    The left subtree of a node contains only nodes with keys less than the node's key.
    The right subtree of a node contains only nodes with keys greater than the node's key.
    Both the left and right subtrees must also be binary search trees.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    bool isValidBST(TreeNode *root, int &min, int &max) {
        if (root == NULL) {
            min = INT_MAX;
            max = INT_MIN;
            return true;
        }
        
        int leftMin, leftMax, rightMin, rightMax;
        if (!isValidBST(root->left, leftMin, leftMax) || !isValidBST(root->right, rightMin, rightMax))
            return false;
        if (root->val <= leftMax || root->val >= rightMin)
            return false;
        min = root->val < leftMin ? root->val : leftMin;
        max = root->val > rightMax ? root->val : rightMax;
        
        return true;
    }
public:
    bool isValidBST(TreeNode *root) {
        int min, max;
        return isValidBST(root, min, max);
    }
};

Climbing Stairs

You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

public class Solution {
    public int climbStairs(int n) {
        if (n <= 0) return 0;
        if (n <= 1) return 1;
         
        int[] array = new int[n+1];
        array[0] = 1;
        array[1] = 1;
        for (int i = 2; i <= n; ++i) {
            array[i] = array[i-1] + array[i-2];
        }
        
        return array[n];
    }
}

Permutations

Given a collection of numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1]. 

public class Solution {
    private ArrayList<ArrayList<Integer>> permute(int[] num, boolean[] selected) {
        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();
        int count = 0;
        for (int i = 0; i < selected.length; ++i) {
            if (!selected[i])
                ++count;
        }
        
        for (int i = 0; i < num.length; ++i) {
            if (!selected[i]) {
                if (count == 1) {
                    ArrayList<Integer> ar = new ArrayList<Integer>();
                    ar.add(num[i]);
                    list.add(ar);
                    return list;
                } else {
                    selected[i] = true;
                    ArrayList<ArrayList<Integer>> tmpList = permute(num, selected);
                    selected[i] = false;
                    
		            Iterator<ArrayList<Integer>> iterator = tmpList.iterator();
		            while (iterator.hasNext()) {
			            iterator.next().add(0, num[i]);
		            }
		            
		            list.addAll(tmpList);
                }
            }
        }
        
        return list;
    }
    
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
        boolean[] selected = new boolean[num.length];
        for (int i = 0; i < selected.length; ++i) {
            selected[i] = false;
        }
        
        return permute(num, selected);
    }
}

Permutations II

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1]. 

public class Solution {
    private ArrayList<ArrayList<Integer>> permute(int[] num, boolean[] selected) {
        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();
        int count = 0;
        for (int i = 0; i < selected.length; ++i) {
            if (!selected[i])
                ++count;
        }
        
        HashSet set = new HashSet();
        for (int i = 0; i < num.length; ++i) {
            if (!selected[i]) {
                if (count == 1) {
                    ArrayList<Integer> ar = new ArrayList<Integer>();
                    ar.add(num[i]);
                    list.add(ar);
                    return list;
                } else if (!set.contains(new Integer(num[i]))) {
                    selected[i] = true;
                    ArrayList<ArrayList<Integer>> tmpList = permute(num, selected);
                    selected[i] = false;
                    
		            Iterator<ArrayList<Integer>> iterator = tmpList.iterator();
		            while (iterator.hasNext()) {
			            iterator.next().add(0, num[i]);
		            }
		            
		            list.addAll(tmpList);
		            set.add(new Integer(num[i]));
                }
            }
        }
        
        return list;
    }
    
    public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
        boolean[] selected = new boolean[num.length];
        for (int i = 0; i < selected.length; ++i) {
            selected[i] = false;
        }
        
        return permute(num, selected);
    }
}

Triangle

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 

class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        for (int i = triangle.size() - 2; i >= 0; --i) {
            for (int j = 0; j < triangle[i].size(); ++j) {
                triangle[i][j] += triangle[i+1][j] > triangle[i+1][j+1] ? triangle[i+1][j+1] : triangle[i+1][j];
            }
        }
        
        return triangle[0][0];
    }
};

Flatten Binary Tree to Linked List

 Given a binary tree, flatten it to a linked list in-place.

For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6

The flattened tree should look like:

   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode *root) {
        if (root == NULL) return;
        
        flatten(root->left);
        TreeNode *right = root->right;
        root->right = root->left;
        root->left = NULL;
        TreeNode *n = root;
        
        while (n->right) n = n->right;
        
        flatten(right);
        n->right = right;
    }
};

Sort Colors

Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.

click to show follow up.

Follow up:
A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

Could you come up with an one-pass algorithm using only constant space?

class Solution {
    void swap(int A[], int i, int j) {
        int tmp = A[i];
        A[i] = A[j];
        A[j] = tmp;
    }
    
public:
    void sortColors(int A[], int n) {
        int front = 0, back = n - 1, i = 0;
        while (i <= back) {
            if (A[i] == 0 && i != front) {
                swap(A, front, i);
                ++front;
            } else if (A[i] == 2 && i != back) {
                swap(A, back, i);
                --back;
            } else ++i;
        }
    }
};

Subsets

Given a set of distinct integers, S, return all possible subsets.

Note:

    Elements in a subset must be in non-descending order.
    The solution set must not contain duplicate subsets.

For example,
If S = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

class Solution {
public:
    vector<vector<int> > subsets(vector<int> &S) {
        long long bits = 0;
        for (int i = 0; i < S.size(); ++i) {
            bits |= (1 << i);
        }
        
        vector<vector<int> > res;
        for (long long i = 0; i <= bits; ++i) {
            vector<int> v;
            for (int j = 0; j < S.size(); ++j) {
                if (((1 << j) & i) != 0)
                    v.push_back(S[j]);
            }
            
            sort(v.begin(), v.end());
            res.push_back(v);
        }
        
        return res;
    }
};

Pascal's Triangle

Given numRows, generate the first numRows of Pascal's triangle.

For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

class Solution {
public:
    vector<vector<int> > generate(int numRows) {
        vector<vector<int> > res;
        if (numRows < 1) return res;
        vector<int> v;
        v.push_back(1);
        res.push_back(v);
        for (int i = 1; i < numRows; ++i) {
          vector<int> vv;
          vv.push_back(1);
          v = res.at(i-1);
          for (int j = 0; j < v.size() - 1; ++j) {
              vv.push_back(v[j]+v[j+1]);
          }
          vv.push_back(1);
          res.push_back(vv);
        }
        
        return res;
    }
};

Pascal's Triangle II

Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space? 

class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> v;
        if (rowIndex < 0) return v;
        v.push_back(1);
        for (int i = 0; i < rowIndex; ++i) {
          vector<int> vv;
          vv.push_back(1);
          for (int j = 0; j < v.size() - 1; ++j) {
              vv.push_back(v[j]+v[j+1]);
          }
          vv.push_back(1);
          v = vv;
        }
        
        return v;       
    }
};

Binary Tree Level Order Traversal

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > res;
        if (root == NULL) return res;
        
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            queue<TreeNode *> q2;
            vector<int> v;
            while (!q.empty()) {
                TreeNode *n = q.front();
                q.pop();
                v.push_back(n->val);
                if (n->left) q2.push(n->left);
                if (n->right) q2.push(n->right);
            }
            res.push_back(v);
            q = q2;
        }
        
        return res;
    }
};


Binary Tree Level Order Traversal II

Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

return its bottom-up level order traversal as:

[
  [15,7]
  [9,20],
  [3],
]

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > tmp;
        if (root == NULL) return tmp;
        
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            queue<TreeNode *> q2;
            vector<int> v;
            while (!q.empty()) {
                TreeNode *n = q.front();
                q.pop();
                v.push_back(n->val);
                if (n->left) q2.push(n->left);
                if (n->right) q2.push(n->right);
            }
            tmp.push_back(v);
            q = q2;
        }
        
        vector<vector<int> > res;
        for (int i = tmp.size() - 1; i >= 0; --i) {
            res.push_back(tmp[i]);
        }
        
        return res;      
    }
};

Populating Next Right Pointers in Each Node

 Given a binary tree

    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

    You may only use constant extra space.
    You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

For example,
Given the following perfect binary tree,

         1
       /  \
      2    3
     / \  / \
    4  5  6  7

After calling your function, the tree should look like:

         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (root == NULL) return;
        
        queue<TreeLinkNode *> q;
        q.push(root);
        while (!q.empty()) {
            queue<TreeLinkNode *> q2;
            TreeLinkNode *prev = NULL;
            TreeLinkNode *n = NULL;
            
            while (!q.empty()) {
                TreeLinkNode *n = q.front();
                q.pop();
                if (prev)
                    prev->next = n;
                prev = n;
                if (n->left) q2.push(n->left);
                if (n->right) q2.push(n->right);
            }
            
            if (n) n->next = NULL;
            
            q = q2;
        }   
    }
};


Count and Say

The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string. 

class Solution {
public:
    string countAndSay(int n) {
        if (n == 1) return "1";
        string s = countAndSay(n - 1);
        
        char v = '0';
        int count = 0;
        string res;
        
        for (int i = 0; i < s.size(); ++i) {
            if (v != s.at(i)) {
                if (v != '0') {
                    ostringstream ss;
                    ss << count;
                    res += ss.str();
                    res += v;
                }
                count = 1;
                v = s.at(i);
            } else ++count;
        }
        
        if (v != '0') {
            ostringstream ss;
            ss << count;
            res += ss.str();
            res += v;
        }
                
        return res;
    }
};
