Two sum:

public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        if (numbers == null)
            return null;
        int[] ret = new int[2];

        HashMap<String, String> map = new HashMap<String, String>();
        for (int i = 0; i < numbers.length; ++i) {
            map.put(Integer.toString(target - numbers[i]), Integer.toString(i));
        }

        for (int i = 0; i < numbers.length; ++i) {
            if (map.containsKey(Integer.toString(numbers[i]))) {
                int val1 = Integer.parseInt(map.get(Integer.toString(numbers[i])));
                int val2 = i;
                if (val1 < val2) {
                    ret[0] = val1 + 1;
                    ret[1] = val2 + 1;
                    return ret;
                } else if (val1 > val2) {
                    ret[0] = val2 + 1;
                    ret[1] = val1 + 1;
                    return ret;
                }
            }
        }

        return null;
    }
}

Binary Tree Postorder Traversal

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ArrayList<Integer> postorderTraversal(TreeNode root) {
        if (root == null) {
            return new ArrayList<Integer>();
        }
        ArrayList<Integer> left = postorderTraversal(root.left);
        ArrayList<Integer> right = postorderTraversal(root.right);
        
        if (left != null && right != null) {
            left.addAll(right);
        } else if (right != null) {
            left = right;
        }
        
        if (left != null) {
            left.add(new Integer(root.val));
        }
        
        return left;
    }
}

Binary Tree Preorder Traversal

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
         if (root == null) {
            return new ArrayList<Integer>();
        }
        ArrayList<Integer> left = preorderTraversal(root.left);
        ArrayList<Integer> right = preorderTraversal(root.right);
        
        ArrayList<Integer> rootNode = new ArrayList<Integer>();
        rootNode.add(root.val);
        
        if (left != null) {
            rootNode.addAll(left);
        }
        
        if (right != null) {
            rootNode.addAll(right);
        }
        
        return rootNode;       
    }
}

Linked List Cycle

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null)
            return false;
            
        ListNode first = head, second = head.next;
        while (first != null && second != null) {
            first = first.next;
            second = second.next;
            if (second == null) {
                return false;
            }
            
            second = second.next;
            
            if (first == second) {
                return true;
            }
        }
        
        return false;
    }
}

Same Tree

Given two binary trees, write a function to check if they are equal or not. 

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;
        if ((p == null && q != null) || (p != null && q == null) )
            return false;
        if (p.val != q.val)
            return false;
        if (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))
            return true;
        return false;
    }
}

Gas Station
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

public class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int i = 0;
        while (i < gas.length) {
            if (gas[i] < cost[i]) {
                ++i;
                continue;
            }
            int gasAmount = gas[i] - cost[i];
            int j = (i + 1) % gas.length;
            while (j != i) {
               gasAmount += gas[j] - cost[j];
               if (gasAmount < 0) {
                   break;
               }
               j = (j + 1) % gas.length;
            }
            
            if (j == i) {
                return j;
            } else if (j > i) {
                i = j + 1;
            } else {
                break;
            }
        }

        return -1;
    }
}

Add Two Numbers

You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    private ListNode add(int num, ListNode l) {
        if (num == 0)
            return l;
            
        ListNode newList;
        if (l != null) {
            newList = new ListNode((l.val + num) % 10);
            num = (l.val + num) / 10;
            l = l.next;
        } else {
            newList = new ListNode(num % 10);
            num = num / 10;           
        }
        
        ListNode cur = newList;
        while (num != 0 && l != null) {
            cur.next = new ListNode((l.val + num) % 10);
            num = (l.val + num) / 10;
            cur = cur.next;
            l = l.next;
        }
        if (num == 0)
            cur.next = l;
        else cur.next = new ListNode(num);
            
        return newList;
    }
    
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null)
            return l2;
        
        if (l2 == null)
            return l1;
            
        int num = (l1.val + l2.val) / 10;
        ListNode head = new ListNode((l1.val + l2.val) % 10);
        ListNode cur = head;
        l1 = l1.next;
        l2 = l2.next;
        
        while (l1 != null && l2 != null) {
           cur.next = new ListNode((l1.val + l2.val + num) % 10);
           num = (l1.val + l2.val + num) / 10;
           cur = cur.next;
           l1 = l1.next;
           l2 = l2.next;
        }
        
        if (l1 != null) {
            cur.next = add(num, l1);
        } else if (l2 != null) {
            cur.next = add(num, l2);
        } else if (num != 0) {
            cur.next = new ListNode(num);
        }
        
        return head;
    }
}

String to Integer (atoi)

public class Solution {
    public int atoi(String str) {
        if (str == null || str.length() == 0)
            return 0;
        
        int length = str.length();
        
        int i = 0;
        while (i < length && str.charAt(i) == ' ')
            ++i;
            
        int sign = 1;
        if (i < length && str.charAt(i) == '-') {
            sign = -1;
            ++i;
        } else if (i < length && str.charAt(i) == '+')
            ++i;
            
        long ret = 0;
        while (i < length) {
            char c = str.charAt(i);
            if (c < '0' || c > '9')
                break;
                
            ret *= 10;
            ret += sign * (c - '0');
            if (sign == 1 && ret >= Integer.MAX_VALUE) {
                ret = Integer.MAX_VALUE;
                break;
            } else if (sign == -1 && ret <= Integer.MIN_VALUE) {
                ret = Integer.MIN_VALUE;
                break;
            }
            ++i;
        }
        
        return (int)ret;
    }
}

Valid Palindrome

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

public class Solution {
    public boolean isPalindrome(String s) {
        if (s == null)
            return true;
        if (s.length() < 2)
            return true;
            
        int i = 0, j = s.length() - 1;
        while (i < j) {
            if (!Character.isLetter(s.charAt(i)) && !Character.isDigit(s.charAt(i))) {
                ++i;
                continue;
            }
            if (!Character.isLetter(s.charAt(j)) && !Character.isDigit(s.charAt(j))) {
                --j;
                continue;
            }
            
            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))
                return false;
            ++i;
            --j;
        }
        
        return true;
    }
}

Binary Tree Maximum Path Sum

Given a binary tree, find the maximum path sum.
The path may start and end at any node in the tree.
For example:
Given the below binary tree,
      1
      / \
     2   3

Return 6.


/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int[] maxPathSumPair(TreeNode root) {
        int[] ret = new int[2];
        ret[0] = 0;
        ret[1] = 0;
        
        if (root == null)
            return ret;
            
        int[] leftRet = maxPathSumPair(root.left);
        int[] rightRet = maxPathSumPair(root.right);
        
        if (leftRet[1] > rightRet[1])
            ret[1] = leftRet[1] + root.val;
        else ret[1] = rightRet[1] + root.val;
        ret[1] = ret[1] > root.val ? ret[1] : root.val;
        
        int sum = ret[1];
        if (root.left != null)
            sum = sum > leftRet[0] ? sum : leftRet[0];
        if (root.right != null)
            sum = sum > rightRet[0] ? sum : rightRet[0];
        
        int tempSum = leftRet[1] + root.val + rightRet[1];
        sum = sum > tempSum ? sum : tempSum;
        sum = sum > root.val ? sum : root.val;
        
        ret[0] = sum;
        
        return ret;
    }
    
    public int maxPathSum(TreeNode root) {
        int[] sumPair = maxPathSumPair(root);
        return sumPair[0];
    }
}

Longest Substring Without Repeating Characters

Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.

public class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null)
            return 0;
            
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        int length = s.length();
        int start = 0, end = 0, curStart = 0;
        
        for (int i = 0; i < length; ++i) {
            Character c = new Character(s.charAt(i));
            if (map.containsKey(c)) {
                if ((i - curStart) > (end - start)) {
                    start = curStart;
                    end = i;
                }
                
                int newPos = map.get(c).intValue();
                for (int j = curStart; j <= newPos; ++j)
                    map.remove(new Character(s.charAt(j)));
                curStart = newPos + 1;
            }
            
            map.put(c, new Integer(i));
        }
        
        if ((length - curStart) > (end - start)) {
            start = curStart;
            end = length;
        }
        
        if (end != 0)
            return end - start;
        return length;
    }
}


Regular Expression Matching ?

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true


Candy
There are N children standing in a line. Each child is assigned a rating value.
You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?

public class Solution {
    public int candy(int[] ratings) {
        if (ratings == null || ratings.length == 0)
            return 0;
            
        int[] candies = new int[ratings.length];
        candies[0] = 1;
        
        for (int i = 1; i < ratings.length; ++i) {
            if (ratings[i] > ratings[i-1])
                candies[i] = candies[i-1] + 1;
            else candies[i] = 1;
        }
        
        for (int i = ratings.length - 2; i >= 0; --i) {
            if (ratings[i] > ratings[i+1] && candies[i] <= candies[i+1])
                candies[i] = candies[i+1] + 1;
        }
        
        int total = 0;
        for (int i = 0; i < ratings.length; ++i)
            total += candies[i];
        
        return total;
    }
}

Longest Palindromic Substring
Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

public class Solution {
    public String longestPalindrome(String s) {
        if (s == null)
           return null;
           
        int start = 0, end = 0;
        int length = s.length();
        for (int i = 0; i < length; ++i) {
            int j = 1;
            while (i - j >= 0 && i + j < length) {
                if (s.charAt(i-j) != s.charAt(i+j))
                    break;
                ++j;
            }
            
            if (end - start < 2 * j - 1) {
                start = i - j + 1;
                end = i + j;
            }
            
            j = i + 1;
            int k = i;
            while (k >= 0 && j < length) {
                if (s.charAt(k) != s.charAt(j))
                    break;
                ++j;
                --k;
            }
            
            if (end - start < j - k - 1) {
                start = k + 1;
                end = j;
            }
        }
        
        return s.substring(start, end);
    }
}

Remove Duplicates from Sorted Array
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this in place with constant memory.
For example,
Given input array A = [1,1,2],
Your function should return length = 2, and A is now [1,2].

public class Solution {
    public int removeDuplicates(int[] A) {
        if (A == null)
            return 0;
            
        HashSet set = new HashSet();
        
        int count = 0, pos = 0;
        for (int i = 0; i < A.length; ++i) {
            if (set.contains(new Integer(A[i])))
                continue;
            else {
                set.add(new Integer(A[i]));
                A[pos++] = A[i];
                ++count;
            }
        }
        
        return count;
    }
}

Symmetric Tree
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree is symmetric:
   1
   / \
  2   2
 / \ / \
3  4 4  3

But the following is not:
   1
   / \
  2   2
   \   \
   3    3


/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private boolean isSymmetricTree(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;
        if ((p == null && q != null) || (p != null && q == null) )
            return false;
        if (p.val != q.val)
            return false;
        if (isSymmetricTree(p.left, q.right) && isSymmetricTree(p.right, q.left))
            return true;
        return false;
    }
    
    public boolean isSymmetric(TreeNode root) {
        if (root == null)
            return true;
        return isSymmetricTree(root.left, root.right);
    }
}

Maximum Depth of Binary Tree
Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        if (leftDepth > rightDepth)
            return leftDepth + 1;
        return rightDepth + 1;
    }
}

Merge Sorted Array
Given two sorted integer arrays A and B, merge B into A as one sorted array.

public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int i = 0, j = 0, p = 0;
        int[] C = new int[m+n];
        while (i < m && j < n) {
            if (A[i] > B[j])
                C[p++] = B[j++];
            else C[p++] = A[i++];
        }
        
        while (i < m)
            C[p++] = A[i++];
        while (j < n)
            C[p++] = B[j++];
            
        for (i = 0; i < m+n; ++i)
            A[i] = C[i];
    }
}

Evaluate Reverse Polish Notation
Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.
Some examples:
 ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

C++:

class Solution {
public:
    int evalRPN(vector<string> &tokens) {
        if (tokens.empty())
            return 0;
 
        string str = tokens.back();
        tokens.pop_back();
        if (str != "+" && str != "-" && str != "*" && str != "/") {
            return atoi(str.c_str());
        }

        int num2;
        string str2 = tokens.back();
        if (str2 != "+" && str2 != "-" && str2 != "*" && str2 != "/") {
            num2 = atoi(str2.c_str());
            tokens.pop_back();
        } else {
            num2 = evalRPN(tokens);
        }
          
        int num1;
        string str1 = tokens.back();
        if (str1 != "+" && str1 != "-" && str1 != "*" && str1 != "/") {
            num1 = atoi(str1.c_str());
            tokens.pop_back();
        } else {
            num1 = evalRPN(tokens);
        }
        
        int ret;
        
        if (str == "+")
            ret = num1 + num2;
        else if (str == "-")
            ret = num1 - num2;
        else if (str == "*")
            ret = num1 * num2;
        else if (str == "/")
            ret = num1 / num2;
                
        return ret;
    }
};

Sort List
Sort a linked list in O(n log n) time using constant space complexity.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        if (head == NULL)
            return NULL;
            
        ListNode *left = NULL, *right = NULL;
        ListNode *cur = head->next, *leftPtr = NULL, *rightPtr = NULL, *headPtr = head;
        while (cur != NULL) {
            ListNode *tmp = cur;
            cur = cur->next;
            if (tmp->val < head->val) {
                if (leftPtr == NULL) {
                    left = tmp;
                    leftPtr = left;
                } else {
                    leftPtr->next = tmp;
                    leftPtr = leftPtr->next;
                }
            } else if (tmp->val > head->val) {
                if (rightPtr == NULL) {
                    right = tmp;
                    rightPtr = right;
                } else {
                    rightPtr->next = tmp;
                    rightPtr = rightPtr->next;
                }
            } else {
                headPtr->next = tmp;
                headPtr = headPtr->next;              
            }
        }
        
        if (leftPtr) {
            leftPtr->next = NULL;
            left = sortList(left);
            leftPtr = left;
            while (leftPtr->next)
                leftPtr = leftPtr->next;
        }
        
        if (rightPtr) {
            rightPtr->next = NULL;
            right = sortList(right);
        }
            
        headPtr->next = right;
        if (leftPtr) {
            leftPtr->next = head;
            return left;
        }
        
        return head;
    }
};

Insertion Sort List
Sort a linked list using insertion sort.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        ListNode *sortedList = NULL;
        while (head != NULL) {
            if (sortedList == NULL) {
                sortedList = head;
                head = head->next;
                sortedList->next = NULL;
                continue;
            }
            
            ListNode *ptr = sortedList, *prevPtr = NULL;
            while (ptr->next != NULL && ptr->val <= head->val) {
                prevPtr = ptr;
                ptr = ptr->next;
            }
            
            if (prevPtr == NULL) {
                if (ptr->val < head->val) {
                    ListNode *tmp = ptr->next;
                    ptr->next = head;
                    head = head->next;
                    ptr->next->next = tmp;
                } else {
                    sortedList = head;
                    head = head->next;
                    sortedList->next = ptr;
                }
            } else if (ptr->val > head->val) {
                prevPtr->next = head;
                head = head->next;
                prevPtr->next->next = ptr;
            } else {
                ptr->next = head;
                head = head->next;
                ptr->next->next = NULL;              
            }
        }
        
        return sortedList;
    }
};

Reorder List

Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}. 


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode *head) {
        if (head == NULL || head->next == NULL)
            return;
            
        vector<ListNode *> v;
        ListNode *ptr = head;
        while (ptr) {
            v.push_back(ptr);
            ptr = ptr->next;
        }
        
        int i = 0, j = v.size() - 1;
        ListNode *lastPtr = NULL;
        while (i < j) {
           ListNode *front = v.at(i);
           ListNode *back = v.at(j);
           
           if (lastPtr != NULL) {
               lastPtr->next = front;
           }
           
           front->next = back;
           lastPtr = back;
               
           ++i;
           --j;
        }
        
        if (i == j) {
            lastPtr->next = v.at(i);
            lastPtr->next->next = NULL;
        } else lastPtr->next = NULL;
    }
};


Sum Root to Leaf Numbers

Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

For example,

    1
   / \
  2   3

The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.

Return the sum = 12 + 13 = 25. 

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int sumNumbers(TreeNode *node, int topNum) {
        if (node == NULL) {
            return 0;
        }
        
        int newTopNum = topNum * 10 + node->val;
        if (node->left == NULL && node->right == NULL) {
            return newTopNum;
        }
        
        int leftSum = 0, rightSum = 0;
        if (node->left)
            leftSum = sumNumbers(node->left, newTopNum);
        if (node->right)
            rightSum = sumNumbers(node->right, newTopNum);
        
        return leftSum + rightSum;
    }
    
public:
    int sumNumbers(TreeNode *root) {
        return sumNumbers(root, 0);
    }
};

Single Number

Given an array of integers, every element appears twice except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 

public class Solution {
    public int singleNumber(int[] A) {
        if (A == null)
            return 0;
            
        HashSet set = new HashSet();
        for (int i = 0; i < A.length; ++i) {
            Integer num = new Integer(A[i]);
            if (set.contains(num)) {
                set.remove(num);
            } else {
                set.add(num);
            }
        }
        
        if (set.size() != 1)
            return 0;
        
        Iterator iterator = set.iterator();
        
        return ((Integer)iterator.next()).intValue();
    }
}

without using extra memory:

class Solution {
public:
    int singleNumber(int A[], int n) {
        int ret = 0;
        for (int i = 0; i < n; ++i)
            ret ^= A[i];
        return ret;
    }
};

Single Number II

Given an array of integers, every element appears three times except for one. Find that single one. 

public class Solution {
    public int singleNumber(int[] A) {
        if (A == null)
            return 0;
            
        HashSet set1 = new HashSet(), set2 = new HashSet();
        for (int i = 0; i < A.length; ++i) {
            Integer num = new Integer(A[i]);
            if (!set1.contains(num)) {
                set1.add(num);
            } else if (!set2.contains(num)) {
                set2.add(num);
            } else {
                set1.remove(num);
                set2.remove(num);
            }
        }
        
        if (set1.size() != 1)
            return 0;
        
        Iterator iterator = set1.iterator();
        
        return ((Integer)iterator.next()).intValue();        
    }
}

Word Break

Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code". 

class Solution {
    bool wordBreak(string s, unordered_set<string> &dict, unordered_set<string> &nonWords) {
        for (int i = 1; i <= s.length(); ++i) {
            unordered_set<string>::const_iterator it = dict.find (s.substr(0, i));
            if (it == dict.end())
                continue;
                
            if (i == s.length())
                return true;
                
            it = nonWords.find (s.substr(i));
            if (it != nonWords.end())
                continue;
                
            if (wordBreak(s.substr(i), dict, nonWords)) {
                return true;
            } else {
                nonWords.insert(s.substr(i));
            }
        }
        
        return false;     
    }
    
public:
    bool wordBreak(string s, unordered_set<string> &dict) {
        unordered_set<string> nonWords;
        return wordBreak(s, dict, nonWords);
    }
};


Word Break II

 Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"]. 

class Solution {
    vector<string> wordBreak(string s, unordered_set<string> &dict, unordered_set<string> &nonWords) {
        vector<string> ret;
        for (int i = 1; i <= s.length(); ++i) {
            unordered_set<string>::const_iterator it = dict.find (s.substr(0, i));
            if (it == dict.end())
                continue;
                
            if (i == s.length()) {
                ret.push_back(s);
                break;
            }
                
            it = nonWords.find (s.substr(i));
            if (it != nonWords.end())
                continue;
                
            vector<string> v = wordBreak(s.substr(i), dict, nonWords);
            if (!v.empty()) {
                  for (vector<string>::iterator it = v.begin(); it != v.end(); ++it) {
                      string newStr = s.substr(0, i).append(" ");
                      newStr = newStr.append(*it);
                      ret.push_back(newStr);
                  }
            } else {
                nonWords.insert(s.substr(i));
            }
        }
    
        return ret;
    }
    
public:
    vector<string> wordBreak(string s, unordered_set<string> &dict) {
        unordered_set<string> nonWords;
        return wordBreak(s, dict, nonWords);        
    }
};


Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0)
            return 0;
            
        int profit = 0, buyIndex = 0, sellIndex = 0;
        for (int i = 1; i < prices.length; ++i) {
            if (prices[buyIndex] > prices[i]) {
                buyIndex = i;
            } else if (prices[sellIndex] < prices[i] || sellIndex < buyIndex) {
                sellIndex = i;
            }
            
            if (prices[sellIndex] - prices[buyIndex] > profit && sellIndex >= buyIndex) {
                profit = prices[sellIndex] - prices[buyIndex];
            }
        }
        
        return profit;
    }
}


Best Time to Buy and Sell Stock II

Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2)
            return 0;
            
        int profit = 0, buyIndex = 0, sellIndex = 0;
        for (int i = 1; i < prices.length - 1; ++i) {
            if (prices[i] <= prices[i-1] && prices[i] <= prices[i+1] && i > sellIndex) {
                buyIndex = i;
            } else if (prices[i] >= prices[i-1] && prices[i] >= prices[i+1] && buyIndex >= sellIndex) {
                profit += prices[i] - prices[buyIndex];
                sellIndex = i;
            }
        }
      
        if (prices[prices.length - 2] < prices[prices.length - 1] && buyIndex >= sellIndex) {
                profit += prices[prices.length - 1] - prices[buyIndex];
        }
        
        return profit;
    }
}


Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    bool isBalanced(TreeNode *root, int &depth) {
        if (root == NULL) {
            depth = 0;
            return true;
        }
        
        int ret = true;
        
        int leftDepth, rightDepth;
        if (!isBalanced(root->left, leftDepth))
            ret = false;
        if (!isBalanced(root->right, rightDepth))
            ret = false;
        if (ret && (leftDepth - rightDepth > 1 || leftDepth - rightDepth < -1))
            ret = false;
            
        if (leftDepth > rightDepth)
            depth = leftDepth + 1;
        else depth = rightDepth + 1;
        
        return ret;
    }
    
public:
    bool isBalanced(TreeNode *root) {
        int depth;
        return isBalanced(root, depth);
    }
};


Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == NULL) {
            return 0;
        }
        
        int leftMinDepth = minDepth(root->left);
        int rightMinDepth = minDepth(root->right);
        
        if (root->left == NULL)
            return rightMinDepth + 1;
            
        if (root->right == NULL)
            return leftMinDepth + 1;
            
        if (leftMinDepth > rightMinDepth)
            return rightMinDepth + 1;
        
        return leftMinDepth + 1;
    }
};

Path Sum

 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == NULL) {
            return false;
        }
        
        if (root->left == NULL && root->right == NULL) {
            return root->val == sum;
        }
        
        if (root->left != NULL) {
            if (hasPathSum(root->left, sum - root->val))
                return true;
        }
        
        if (root->right != NULL) {
            if (hasPathSum(root->right, sum - root->val))
                return true;
        }
        
        return false;
    }
};


Path Sum II

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

return

[
   [5,4,11,2],
   [5,8,4,5]
]

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > pathSum(TreeNode *root, int sum) {
        vector<vector<int> > ret;
        if (root == NULL) {
            return ret;
        }
        
        if (root->left == NULL && root->right == NULL) {
            if (root->val == sum) {
                vector<int> v;
                v.push_back(root->val);
                ret.push_back(v);
            }
            return ret;
        }
        
        if (root->left != NULL) {
            vector<vector<int> > leftV = pathSum(root->left, sum - root->val);
            for (vector<vector<int> >::iterator it = leftV.begin(); it != leftV.end(); ++it) {
                (*it).insert((*it).begin(), root->val);
                ret.push_back(*it);
            }
        }
        
        if (root->right != NULL) {
            vector<vector<int> > rightV = pathSum(root->right, sum - root->val);
            for (vector<vector<int> >::iterator it = rightV.begin(); it != rightV.end(); ++it) {
                (*it).insert((*it).begin(), root->val);
                ret.push_back(*it);
            }
        }
        
        return ret;       
    }
};


Word Ladder

 Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:

    Only one letter can be changed at a time
    Each intermediate word must exist in the dictionary

For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]

As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.

Note:

    Return 0 if there is no such transformation sequence.
    All words have the same length.
    All words contain only lowercase alphabetic characters.

class Solution {
public:
    int ladderLength(string start, string end, unordered_set<string> &dict) {
        if (start == end)
            return 1;
            
        unordered_set<string> checked;
        queue<string> queue, tmpQueue;
        queue.push(start);
        checked.insert(start);
        int level = 1;
        while(!queue.empty()) {
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                string s = queue.front();
                queue.pop();
                 
                for (int j = 0; j < s.size(); ++j) {
                    char cc = s[j];
                    for (char c = 'a'; c <= 'z'; ++c) {
                        if (s[j] != c) {
                            s[j] = c;
                            if (dict.find(s) != dict.end() && checked.count(s) == 0) {
                                if (s == end)
                                    return level + 1;
                                tmpQueue.push(s);
                                checked.insert(s);
                            }
                        }
                    }
                    s[j] = cc;
                }
            }
            
            swap(queue, tmpQueue);
            ++level;
        }
        
        return 0;
    }
};


Binary Tree Inorder Traversal

Given a binary tree, return the inorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3

return [1,3,2].

Note: Recursive solution is trivial, could you do it iteratively?

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> v;
        if (root == NULL)
            return v;
        vector<int> left = inorderTraversal(root->left);
        vector<int> right = inorderTraversal(root->right);
        
        left.push_back(root->val);
        left.insert(left.end(), right.begin(), right.end());
        
        return left;
    }
};

Remove Nth Node From End of List

Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

   After removing the second node from the end, the linked list becomes 1->2->3->5.

Note:
Given n will always be valid.
Try to do this in one pass. 

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        ListNode *first = head, *second = NULL;
        for (int i = 0; i < n; ++i)
            first = first->next;
            
        if (first) {
            first = first->next;
            second = head;
        }
        
        while (first) {
            first = first->next;
            second = second->next;
        }
        
        if (second == NULL) {
            second = head;
            head = head->next;
            delete second;
            return head;
        }
        
        ListNode *tmp = second->next;
        second->next = second->next->next;
        delete tmp;
        
        return head;
    }
};
